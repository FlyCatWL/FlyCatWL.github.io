<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SVPWM</title>
    <link href="/2022/11/25/Foc/Control/SVPWM/"/>
    <url>/2022/11/25/Foc/Control/SVPWM/</url>
    
    <content type="html"><![CDATA[<h2 id="1-SVPWM原理"><a href="#1-SVPWM原理" class="headerlink" title="1.SVPWM原理"></a>1.SVPWM原理</h2><p>​矢量控制的数学模型，目的是在空间中合成圆形恒定的旋转磁链(磁场)，即合成一个恒定大小的旋转电压矢量。</p><h2 id="2-SVPWM实现步骤"><a href="#2-SVPWM实现步骤" class="headerlink" title="2.SVPWM实现步骤"></a>2.SVPWM实现步骤</h2><h3 id="2-1扇区划分"><a href="#2-1扇区划分" class="headerlink" title="2.1扇区划分"></a>2.1扇区划分</h3><h3 id="2-2扇区判断"><a href="#2-2扇区判断" class="headerlink" title="2.2扇区判断"></a>2.2扇区判断</h3><h3 id="2-3逆变切换时间"><a href="#2-3逆变切换时间" class="headerlink" title="2.3逆变切换时间"></a>2.3逆变切换时间</h3>]]></content>
    
    
    <categories>
      
      <category>FOC_CONTROL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>blogWorkFlow.md</title>
    <link href="/2022/11/24/blogWorkFlow/"/>
    <url>/2022/11/24/blogWorkFlow/</url>
    
    <content type="html"><![CDATA[<p>创建新的blog : hexo new “BlogName”<br>github发布:    hexo g &amp;&amp; hexo d</p><p>常见指令： hexo clean 清除缓存</p><p> 常见问题：</p><ol><li><p>ERROR Database load failed. Deleting database.</p><p>解决办法: </p><p>(1) 发现需要修改博客根目录下的 <code>package.json</code> 中的 hexo 版本</p><p>(2) 删掉根目录下的 <code>node_modules</code> 和 <code>package-lock.json</code> </p><p>(3) npm install</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>自举电容</title>
    <link href="/2022/11/24/Foc/Hardware/%E8%87%AA%E4%B8%BE%E7%94%B5%E5%AE%B9%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2022/11/24/Foc/Hardware/%E8%87%AA%E4%B8%BE%E7%94%B5%E5%AE%B9%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="自举电容"><a href="#自举电容" class="headerlink" title="自举电容"></a>自举电容</h1><h2 id="1-原理"><a href="#1-原理" class="headerlink" title="1.原理"></a>1.原理</h2><p>​自居电容的原理是：电容两端的电压不能突变。</p><p>​<em>不能突变则指电容两端电压变化时，必然需要一个放电或者充电的过程时间</em></p><p><em>根据电容的公式I&#x3D;C</em>dU&#x2F;dt，得知，dU&#x2F;dt&#x3D;I&#x2F;C，故电容两端电压从0V上升到VDD时，取决于电流和电容的比值。<strong>容值一定时，电流越大，电压上升越快。电流一定时，容值越小，电压上升越快</strong>。</p><h2 id="2-模型"><a href="#2-模型" class="headerlink" title="2.模型"></a>2.模型</h2><p><img src="https://cdn.jsdelivr.net/gh/FlyCatWL/PicoGo@master/img/image-20221124133417920.png" alt="image-20221124133417920"></p><p><strong>利用该电路将VOUT输出一个+10V的电压</strong></p><ol><li>VCC为+5V时，K1断开，K2闭合，NMOS导通。通过二极管电容开始充电过程，VOUT输出为+5V。</li><li>K1闭合，K2断开，NMOS关闭，电容原接地引脚电平抬升至+5V，此时VOUT为+10V，二极管反向截止。</li></ol><h2 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h2><h3 id="3-1-电源-Todo"><a href="#3-1-电源-Todo" class="headerlink" title="3.1 电源(Todo)"></a>3.1 电源(Todo)</h3><h3 id="3-2-电机驱动"><a href="#3-2-电机驱动" class="headerlink" title="3.2 电机驱动"></a>3.2 电机驱动</h3><p><img src="https://cdn.jsdelivr.net/gh/FlyCatWL/PicoGo@master/img/image-20221124145021102.png" alt="image-20221124145021102"></p><p><strong>组成</strong></p><p>(1) 自举升压泵控制电路，CFT1、CFT2、CBOOT</p><p>(2) 电平转换控制(半桥驱动)电路 DFT1、DFT2</p><p><strong>升压过程</strong></p><p>(1) 升压泵控制器控制CFT1关闭、CFT2开启，自举电容CBOOT完成充电过程。</p><p>(2) 升压泵控制器控制CFT1开启、CFT2关闭，CPH点电压抬升，经上方二极管，VCP电压抬升。</p><p>(3) 电平转换电路控制DFT1开启、DFT2关闭，上桥臂GS大于开启阈值导通。</p><h2 id="4-选型计算"><a href="#4-选型计算" class="headerlink" title="4.选型计算"></a>4.选型计算</h2><p><a href="https://zhuanlan.zhihu.com/p/572081606">一文说透自举电路：工作原理及自举电阻和电容的选取 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>FOC_CONTROL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动滤波器</title>
    <link href="/2022/04/22/Embedded/Filter/%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2022/04/22/Embedded/Filter/%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>以FreeRTOS的这种机制为参考，我们可以模仿着实现一个简单的滤波器，可以用于对传感器的原始数据进行滤波。</p><p>先来分析一下基本原理：</p><ul><li>设定我们的滑动平均滤波器的窗口宽度为5，可以使用一个数组来实现</li><li>使用一个index来指示下次数据将要存放在数组中的位置</li><li>初始状态，滤波器数组都是0，index指向数组的起始位置</li></ul><p><img src="https://pic3.zhimg.com/80/v2-74358bf729925a791596db0e750cef22_720w.jpg" alt="img"></p><p><strong>开始阶段</strong></p><p>原始数据依次存入滤波器数组，这时的滤波器输出有两种选择：</p><ul><li>方式1：既然数组还未存满，就先不输出滤波结果</li><li>方式2：虽然数组还未存满，但可以计算已经存入的这几个数的平均值作为滤波输出</li></ul><p>这两种方式只在初始阶段存在差别，本文后续编码将采用方式2。</p><p><img src="https://pic2.zhimg.com/80/v2-19cb36b3e9f4f502d64d0d0ca8a15ca5_1440w.jpg" alt="img"></p><p><strong>数据第1次存满滤波器数组</strong></p><p>数据继续存入滤波器数组，当恰好存满时，就可以计算整个数组的平均值了，作为此次的滤波结果。</p><p><img src="https://pic4.zhimg.com/80/v2-8f94f162d09f76be390a58ea0a872443_1440w.jpg" alt="img"></p><p><strong>滑动存储阶段</strong></p><p>滤波器数组首次存满后，就需要进行覆盖存储了(实现滑动获取数据的效果)。</p><p>这里也有两种方式：</p><ul><li>方式1：将新的数据(a5)覆盖存入最早的数据(a0)，然后遍历数组求和，再求平均值作为输出</li><li>方式2：借用上次的求和数据<code>sum</code>(a0~a4)，将<code>sum</code>先减去最早的数据(a0)，加上新的数据(a5)，再将新的数据(a5)覆盖存入最早的数据(a0)，最后对<code>sum</code>除以5求平均值作为输出</li></ul><p>相比较而言，方式2的计算量更小，本文后续编码将采用方式2。</p><p><img src="https://pic3.zhimg.com/80/v2-ac2102a26a772ad486f2176f2fce476a_1440w.jpg" alt="img"></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>下面来看一下编码实现：</p><p><strong>滤波器控制块</strong></p><p>参考FreeRTOS的设计方式，为我们的滑动平均滤波器设计一个控制块，也就是一个结构体，该结构体包含滤波器所需要的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*滑动平均滤波器——结构体*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SlipAveFilter</span></span><br><span class="hljs-class">&#123;</span><br>    u16 len;     <span class="hljs-comment">/*窗口宽度*/</span><br>    u16 index;   <span class="hljs-comment">/*索引*/</span><br>    u16 has;     <span class="hljs-comment">/*已有的数据个数*/</span><br>    <span class="hljs-type">char</span> isfull; <span class="hljs-comment">/*数组数据是否已满*/</span><br>    <span class="hljs-type">float</span> *data; <span class="hljs-comment">/*滤波器数组*/</span><br>    <span class="hljs-type">float</span> sum;   <span class="hljs-comment">/*求和*/</span><br>    <span class="hljs-type">float</span> res;   <span class="hljs-comment">/*滤波结果*/</span><br><br>&#125; SAFiter_t;<br></code></pre></td></tr></table></figure><p><strong>创建滤波器</strong></p><p>参考FreeRTOS的设计方式，使用滤波器时，通过创建函数来创建一个滤波器，创建好之后，会返回一个句柄以供后续对滤波器操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">滑动平均滤波器——创建</span><br><span class="hljs-comment">len：滤波器的窗口宽度</span><br><span class="hljs-comment">返回创建的滤波器句柄</span><br><span class="hljs-comment">*/</span><br>SAFilterHandle_t <span class="hljs-title function_">SlipAveFilterCreate</span><span class="hljs-params">(u16 len)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>)<br>    &#123;<br>        len = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//创建一个滤波器并初始化</span><br>    SAFiter_t *newFilter;<br>    newFilter = MALLOC(<span class="hljs-keyword">sizeof</span>(SAFiter_t));<br>    newFilter-&gt;data = MALLOC(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>));<br>    newFilter-&gt;len = len;<br>    newFilter-&gt;index = <span class="hljs-number">0</span>;<br>    newFilter-&gt;has = <span class="hljs-number">0</span>;<br>    newFilter-&gt;isfull = <span class="hljs-number">0</span>;<br>    newFilter-&gt;sum = <span class="hljs-number">0</span>;<br>    newFilter-&gt;res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> newFilter;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取滤波结果</strong></p><p>参考FreeRTOS的设计方式，在获取滤波结果时，将之前创建的滤波器句柄作为参数传进来，实现对特定滤波数据的获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">滑动平均滤波器——获取结果</span><br><span class="hljs-comment">SAFiter：滤波器句柄</span><br><span class="hljs-comment">input：未滤波的原始数据</span><br><span class="hljs-comment">返回滤波结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetSAFiterRes</span><span class="hljs-params">(SAFilterHandle_t SAFiter, <span class="hljs-type">float</span> input)</span><br>&#123;<br>    SAFiter_t *pFilter = (SAFiter_t *)SAFiter;<br><br>    <span class="hljs-keyword">if</span>(!pFilter-&gt;isfull) <span class="hljs-comment">/*还没有存满*/</span><br>    &#123;<br>        pFilter-&gt;has++; <span class="hljs-comment">/*求当前数组中已有数据数量*/</span><br>        <span class="hljs-keyword">if</span>(pFilter-&gt;has == pFilter-&gt;len)<br>        &#123;<br>            pFilter-&gt;isfull = <span class="hljs-number">1</span>; <span class="hljs-comment">/*标记数组已满*/</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/*已存满，覆盖写入*/</span><br>    &#123;<br>        pFilter-&gt;sum -= pFilter-&gt;data[pFilter-&gt;index]; <span class="hljs-comment">/*先移除最早的数据*/</span> <br>    &#125;<br><br>    <span class="hljs-comment">/*写入新的数据*/</span><br>    pFilter-&gt;data[pFilter-&gt;index] = input; <br><br>    <span class="hljs-comment">/*求当前数组中已有数据的总和*/</span><br>    pFilter-&gt;sum += input; <br><br>    <span class="hljs-comment">/*更新下次数据的索引号*/</span><br>    pFilter-&gt;index = (pFilter-&gt;index == pFilter-&gt;len - <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : pFilter-&gt;index + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/*求当前数组中已有数据的平均值*/</span><br>    pFilter-&gt;res = pFilter-&gt;sum / pFilter-&gt;has;<br><br>    <span class="hljs-keyword">return</span> pFilter-&gt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以MPU6050陀螺仪的数据滤波为例(相关介绍参考</p><p><a href="https://zhuanlan.zhihu.com/p/165156300">码农爱学习：MPU6050姿态解算方式1-DMP43 赞同 · 11 评论文章<img src="https://pic4.zhimg.com/v2-0743b0b1a10be5aab3aa09692ce45723_180x120.jpg" alt="img"></a></p><p>)，假设需要对pitch数据和roll数据进行滤波，使用方式为：</p><ul><li>定义2滤波器句柄</li><li>创建2滤波器</li><li>循环获取数据并滤波</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//滤波器句柄</span><br>SAFilterHandle_t SAFilter_pitch;<br>SAFilterHandle_t SAFilter_roll;<br><br><span class="hljs-comment">//创建2个滤波器</span><br>SAFilter_pitch = SlipAveFilterCreate(<span class="hljs-number">10</span>);<br>SAFilter_roll = SlipAveFilterCreate(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//循环获取数据并滤波</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw,&amp;accx,&amp;accy,&amp;accz,&amp;gyrox,&amp;gyroy,&amp;gyroz)==<span class="hljs-number">0</span>)<br>    &#123; <br>        pitch_res = GetSAFiterRes(SAFilter_pitch,pitch);<span class="hljs-comment">//pitch数据滤波结果</span><br>        roll_res = GetSAFiterRes(SAFilter_roll,roll);<span class="hljs-comment">//roll数据滤波结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pitch:%f,%f,roll:%f,%f\r\n&quot;</span>,pitch,pitch_res,roll,roll_res);<span class="hljs-comment">//打印原始数据与滤波后的数据</span><br>    &#125;<br>    vTaskDelay(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注：滤波器的句柄就是一个void*型的指针，在滤波器的头文件(filters.h)中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __FILTERS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FILTERS_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> u16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> * SAFilterHandle_t;<br><br>SAFilterHandle_t <span class="hljs-title function_">SlipAveFilterCreate</span><span class="hljs-params">(u16 len)</span>;<br><span class="hljs-type">float</span> <span class="hljs-title function_">GetSAFiterRes</span><span class="hljs-params">(SAFilterHandle_t SAFiter, <span class="hljs-type">float</span> input)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>滤波后的结果如下，蓝色为原始数据，橙色为滤波后的结果：</p><p><img src="https://pic4.zhimg.com/80/v2-4a3501af44f00faa37f5fb6b682bf94b_1440w.jpg" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>FILTER</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>

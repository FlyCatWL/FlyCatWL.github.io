<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>blogWorkFlow.md</title>
    <link href="/2022/11/24/blogWorkFlow-md/"/>
    <url>/2022/11/24/blogWorkFlow-md/</url>
    
    <content type="html"><![CDATA[<p>创建新的blog : hexo new “BlogName”<br>github发布:    hexo g &amp;&amp; hexo d</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>blogWorkFlow.md</title>
    <link href="/2022/11/24/Foc-Control-%E8%87%AA%E4%B8%BE%E7%94%B5%E5%AE%B9%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/11/24/Foc-Control-%E8%87%AA%E4%B8%BE%E7%94%B5%E5%AE%B9%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>创建新的blog : hexo new “BlogName”<br>github发布:    hexo g &amp;&amp; hexo d</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>第二篇测试</title>
    <link href="/2022/04/25/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/04/25/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>测试完成</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>滑动滤波器原理</title>
    <link href="/2022/04/22/Embedded-Filter-%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <url>/2022/04/22/Embedded-Filter-%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>以FreeRTOS的这种机制为参考，我们可以模仿着实现一个简单的滤波器，可以用于对传感器的原始数据进行滤波。</p><p>先来分析一下基本原理：</p><ul><li>设定我们的滑动平均滤波器的窗口宽度为5，可以使用一个数组来实现</li><li>使用一个index来指示下次数据将要存放在数组中的位置</li><li>初始状态，滤波器数组都是0，index指向数组的起始位置</li></ul><p><img src="https://pic3.zhimg.com/80/v2-74358bf729925a791596db0e750cef22_720w.jpg" alt="img"></p><p><strong>开始阶段</strong></p><p>原始数据依次存入滤波器数组，这时的滤波器输出有两种选择：</p><ul><li>方式1：既然数组还未存满，就先不输出滤波结果</li><li>方式2：虽然数组还未存满，但可以计算已经存入的这几个数的平均值作为滤波输出</li></ul><p>这两种方式只在初始阶段存在差别，本文后续编码将采用方式2。</p><p><img src="https://pic2.zhimg.com/80/v2-19cb36b3e9f4f502d64d0d0ca8a15ca5_1440w.jpg" alt="img"></p><p><strong>数据第1次存满滤波器数组</strong></p><p>数据继续存入滤波器数组，当恰好存满时，就可以计算整个数组的平均值了，作为此次的滤波结果。</p><p><img src="https://pic4.zhimg.com/80/v2-8f94f162d09f76be390a58ea0a872443_1440w.jpg" alt="img"></p><p><strong>滑动存储阶段</strong></p><p>滤波器数组首次存满后，就需要进行覆盖存储了(实现滑动获取数据的效果)。</p><p>这里也有两种方式：</p><ul><li>方式1：将新的数据(a5)覆盖存入最早的数据(a0)，然后遍历数组求和，再求平均值作为输出</li><li>方式2：借用上次的求和数据<code>sum</code>(a0~a4)，将<code>sum</code>先减去最早的数据(a0)，加上新的数据(a5)，再将新的数据(a5)覆盖存入最早的数据(a0)，最后对<code>sum</code>除以5求平均值作为输出</li></ul><p>相比较而言，方式2的计算量更小，本文后续编码将采用方式2。</p><p><img src="https://pic3.zhimg.com/80/v2-ac2102a26a772ad486f2176f2fce476a_1440w.jpg" alt="img"></p><h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><p>下面来看一下编码实现：</p><p><strong>滤波器控制块</strong></p><p>参考FreeRTOS的设计方式，为我们的滑动平均滤波器设计一个控制块，也就是一个结构体，该结构体包含滤波器所需要的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*滑动平均滤波器——结构体*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SlipAveFilter</span></span><br><span class="hljs-class">&#123;</span><br>    u16 len;     <span class="hljs-comment">/*窗口宽度*/</span><br>    u16 index;   <span class="hljs-comment">/*索引*/</span><br>    u16 has;     <span class="hljs-comment">/*已有的数据个数*/</span><br>    <span class="hljs-type">char</span> isfull; <span class="hljs-comment">/*数组数据是否已满*/</span><br>    <span class="hljs-type">float</span> *data; <span class="hljs-comment">/*滤波器数组*/</span><br>    <span class="hljs-type">float</span> sum;   <span class="hljs-comment">/*求和*/</span><br>    <span class="hljs-type">float</span> res;   <span class="hljs-comment">/*滤波结果*/</span><br><br>&#125; SAFiter_t;<br></code></pre></td></tr></table></figure><p><strong>创建滤波器</strong></p><p>参考FreeRTOS的设计方式，使用滤波器时，通过创建函数来创建一个滤波器，创建好之后，会返回一个句柄以供后续对滤波器操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">滑动平均滤波器——创建</span><br><span class="hljs-comment">len：滤波器的窗口宽度</span><br><span class="hljs-comment">返回创建的滤波器句柄</span><br><span class="hljs-comment">*/</span><br>SAFilterHandle_t <span class="hljs-title function_">SlipAveFilterCreate</span><span class="hljs-params">(u16 len)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(len &lt; <span class="hljs-number">1</span>)<br>    &#123;<br>        len = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//创建一个滤波器并初始化</span><br>    SAFiter_t *newFilter;<br>    newFilter = MALLOC(<span class="hljs-keyword">sizeof</span>(SAFiter_t));<br>    newFilter-&gt;data = MALLOC(len * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>));<br>    newFilter-&gt;len = len;<br>    newFilter-&gt;index = <span class="hljs-number">0</span>;<br>    newFilter-&gt;has = <span class="hljs-number">0</span>;<br>    newFilter-&gt;isfull = <span class="hljs-number">0</span>;<br>    newFilter-&gt;sum = <span class="hljs-number">0</span>;<br>    newFilter-&gt;res = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> newFilter;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>获取滤波结果</strong></p><p>参考FreeRTOS的设计方式，在获取滤波结果时，将之前创建的滤波器句柄作为参数传进来，实现对特定滤波数据的获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">滑动平均滤波器——获取结果</span><br><span class="hljs-comment">SAFiter：滤波器句柄</span><br><span class="hljs-comment">input：未滤波的原始数据</span><br><span class="hljs-comment">返回滤波结果</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">float</span> <span class="hljs-title function_">GetSAFiterRes</span><span class="hljs-params">(SAFilterHandle_t SAFiter, <span class="hljs-type">float</span> input)</span><br>&#123;<br>    SAFiter_t *pFilter = (SAFiter_t *)SAFiter;<br><br>    <span class="hljs-keyword">if</span>(!pFilter-&gt;isfull) <span class="hljs-comment">/*还没有存满*/</span><br>    &#123;<br>        pFilter-&gt;has++; <span class="hljs-comment">/*求当前数组中已有数据数量*/</span><br>        <span class="hljs-keyword">if</span>(pFilter-&gt;has == pFilter-&gt;len)<br>        &#123;<br>            pFilter-&gt;isfull = <span class="hljs-number">1</span>; <span class="hljs-comment">/*标记数组已满*/</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/*已存满，覆盖写入*/</span><br>    &#123;<br>        pFilter-&gt;sum -= pFilter-&gt;data[pFilter-&gt;index]; <span class="hljs-comment">/*先移除最早的数据*/</span> <br>    &#125;<br><br>    <span class="hljs-comment">/*写入新的数据*/</span><br>    pFilter-&gt;data[pFilter-&gt;index] = input; <br><br>    <span class="hljs-comment">/*求当前数组中已有数据的总和*/</span><br>    pFilter-&gt;sum += input; <br><br>    <span class="hljs-comment">/*更新下次数据的索引号*/</span><br>    pFilter-&gt;index = (pFilter-&gt;index == pFilter-&gt;len - <span class="hljs-number">1</span>) ? <span class="hljs-number">0</span> : pFilter-&gt;index + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">/*求当前数组中已有数据的平均值*/</span><br>    pFilter-&gt;res = pFilter-&gt;sum / pFilter-&gt;has;<br><br>    <span class="hljs-keyword">return</span> pFilter-&gt;res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以MPU6050陀螺仪的数据滤波为例(相关介绍参考</p><p><a href="https://zhuanlan.zhihu.com/p/165156300">码农爱学习：MPU6050姿态解算方式1-DMP43 赞同 · 11 评论文章<img src="https://pic4.zhimg.com/v2-0743b0b1a10be5aab3aa09692ce45723_180x120.jpg" alt="img"></a></p><p>)，假设需要对pitch数据和roll数据进行滤波，使用方式为：</p><ul><li>定义2滤波器句柄</li><li>创建2滤波器</li><li>循环获取数据并滤波</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//滤波器句柄</span><br>SAFilterHandle_t SAFilter_pitch;<br>SAFilterHandle_t SAFilter_roll;<br><br><span class="hljs-comment">//创建2个滤波器</span><br>SAFilter_pitch = SlipAveFilterCreate(<span class="hljs-number">10</span>);<br>SAFilter_roll = SlipAveFilterCreate(<span class="hljs-number">10</span>);<br><br><span class="hljs-comment">//循环获取数据并滤波</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-keyword">if</span>(mpu_dmp_get_data(&amp;pitch,&amp;roll,&amp;yaw,&amp;accx,&amp;accy,&amp;accz,&amp;gyrox,&amp;gyroy,&amp;gyroz)==<span class="hljs-number">0</span>)<br>    &#123; <br>        pitch_res = GetSAFiterRes(SAFilter_pitch,pitch);<span class="hljs-comment">//pitch数据滤波结果</span><br>        roll_res = GetSAFiterRes(SAFilter_roll,roll);<span class="hljs-comment">//roll数据滤波结果</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pitch:%f,%f,roll:%f,%f\r\n&quot;</span>,pitch,pitch_res,roll,roll_res);<span class="hljs-comment">//打印原始数据与滤波后的数据</span><br>    &#125;<br>    vTaskDelay(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注：滤波器的句柄就是一个void*型的指针，在滤波器的头文件(filters.h)中有定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __FILTERS_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __FILTERS_H</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> u16;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> * SAFilterHandle_t;<br><br>SAFilterHandle_t <span class="hljs-title function_">SlipAveFilterCreate</span><span class="hljs-params">(u16 len)</span>;<br><span class="hljs-type">float</span> <span class="hljs-title function_">GetSAFiterRes</span><span class="hljs-params">(SAFilterHandle_t SAFiter, <span class="hljs-type">float</span> input)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>滤波后的结果如下，蓝色为原始数据，橙色为滤波后的结果：</p><p><img src="https://pic4.zhimg.com/80/v2-4a3501af44f00faa37f5fb6b682bf94b_1440w.jpg" alt="img"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
